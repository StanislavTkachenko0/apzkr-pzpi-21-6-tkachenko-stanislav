Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизацій процесу розподілення інвестицій у бізнес-проекти

Студент гр. ПЗПІ-21-6		 __________________ Ткаченко С.М.
(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
(підпис) 
Роботу захищено «__»_________2024 р.
з оцінкою _________________________ 

Комісія: 				___________________ доц. Лещинський В.О. 
(підпис)
___________________ доц. Лещинська І.О. 
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук		 Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення				
Курс                     3                     Семестр 	                  6 				
Навчальна дисципліна Архітектура програмного забезпечення			

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ  
                                        Ткаченку Станіславу Максимовичу				
1. Тема проекту: Програмна система для автоматизацій процесу розподілення інвестицій у бізнес-проекти                                                                             	
2. Термін узгодження завдання курсової роботи «_20_»_березня_ 2024 р.
3. Термін здачі студентом закінченої роботи «  10  »   червня    2024 р.  
4. Вихідні дані до проекту: в програмній системі передбачити: аналіз інвестиційних пропозицій за різними критеріями, можливість пошуку інвестицій проектами, створення звітності про інвестиційні рішення, а також візуалізацію фінансових показників та результатів інвестиційної діяльності. Використовувати СКБД Microsoft SQL Server, середовища розробки Microsoft Visual Studio 2022 та Visual Studio Code.                       	
5. Зміст пояснювальної записки (перелік питань, що належить розробити):
вступ, аналіз предметної області, постановка задачі, проектування частин програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань,  додатки 	                                                                         		
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): 
схема бази даних, діаграма варіантів використання, діаграма розгортання, діаграма пакетів, діаграма компонентів, зображення з інтерфейсом програмного продукту 				                              			    

КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів	Примітка
1	Функціональна специфікація 
програмного проекту	30 березня 
2024 року	
2	Проектування програмного 
проекту	10 квітня
2024 року	
3	Кодування програмного проекту	30 квітня 
2024 року	
4	Оформлення пояснювальної 
записки	20 травня 
2024 року	
5	Захист курсової роботи	10 червня 
2024 року	

Дата видачі завдання «__20__»____ березня____2024 р.  

Керівник 				 ______________  ст.викл. Сокорчук І.П.
(підпис)  
Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-6			 _____________		 Ткаченко С.М.
         (підпис)

РЕФЕРАТ


Пояснювальна записка до курсового проектування: 63 с., 28 рис., 1 табл., 6 джерел, 2 додатки.
АРХІТЕКТУРА ПРОГРАМИ, ІНВЕСТИЦІЇ, БІЗНЕС-ПРОЕКТИ, ІНТЕРНЕТ РЕЧЕЙ, КЛІЄНТ, МОВА ПРОГРАМУВАННЯ C#, ОБ’ЄКТНО-ОРІЄНТОВАНЕ ПРОГРАМУВАННЯ, ANGULAR, ASP.NET CORE, SQL SERVER, JWT, VISUAL STUDIO
Метою курсового проекту є створення інформаційної системи для автоматизації процесу розподілення інвестицій у бізнес-проекти. Розроблена система включає серверну частину на базі ASP.NET Core, клієнтську частину, створену за допомогою Angular, і базу даних на SQL Server. Система забезпечує ефективне управління інвестиціями, підтримує моніторинг проектів та забезпечує безпечну взаємодію між інвесторами та проектами.
У процесі реалізації було використано сучасні технології для забезпечення високої безпеки та масштабованості. Авторизація реалізована за допомогою JWT, що гарантує захист конфіденційної інформації. Клієнтська частина системи забезпечує зручний інтерфейс для користувачів, а серверна частина — ефективну обробку даних і взаємодію з базою даних.
Результатом роботи є стабільний та масштабований продукт, який відповідає вимогам сучасного ринку інвестицій. Система дозволяє автоматизувати процес розподілу інвестицій, покращити управління інвестиційними можливостями та забезпечити високий рівень безпеки даних. Розроблений продукт продемонстрував ефективність у вирішенні завдань управління інвестиціями та є готовим до подальшого використання.
ЗМІСТ


ВСТУП


У сучасному світі бізнеси відіграють важливу роль в економічному зростанні та інноваційному розвитку, надаючи нові ідеї та продукти, які здатні змінити різні галузі. Водночас, одним з найважливіших завдань для стартапів є залучення інвестицій, які допомагають їм розвиватися та масштабувати свої рішення. Проте процес пошуку інвесторів і розподілення інвестицій часто виявляється складним та неефективним, що може обмежити можливості стартапів у досягненні їхніх цілей.
Для успішного функціонування на ринку стартапи потребують не лише фінансової підтримки, але й розуміння інвестиційних ризиків і потенціалу зростання. З іншого боку, інвестори також стикаються з проблемою пошуку перспективних проектів, оцінки їхньої життєздатності та прийняття рішень щодо вкладення капіталу. Це створює попит на автоматизовані рішення, які б спрощували процес взаємодії між стартапами та інвесторами, забезпечуючи зручність, прозорість та обґрунтованість рішень.
Розробка програмної системи для автоматизації процесу розподілення інвестицій у бізнес-проекти спрямована на вирішення цих проблем. Система буде включати серверну та клієнтську частини, а також мобільний додаток для зручного використання. Головні функції системи включають створення стартапами запитів на інвестиції, можливість інвесторам шукати та оцінювати ці запити, підписувати контракти та відстежувати результати інвестування. Окрім того, система використовуватиме алгоритми для автоматизованого підбору релевантних стартапів для інвесторів на основі їхніх вподобань та ризиків, що дозволить підвищити ефективність інвестиційних рішень.
Актуальність теми пов'язана з необхідністю підтримки інноваційного розвитку та економічного зростання, створенням ефективної платформи для взаємодії стартапів та інвесторів, а також забезпеченням справедливого та обґрунтованого розподілення капіталу. Використання сучасних технологій для автоматизації цих процесів відкриває нові можливості як для стартапів, так і для інвесторів, сприяючи підвищенню рівня прозорості та довіри у фінансових відносинах.
Метою даної курсової роботи є створення програмної системи, яка автоматизує процеси розподілення інвестицій у стартапи, забезпечує зручність та ефективність для обох сторін. У процесі розробки системи буде проведено аналіз вимог і потреб користувачів, спроектовано архітектуру програмної системи, розроблено алгоритми для автоматизованого підбору стартапів та реалізовано всі необхідні функціональні компоненти.

⦁	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
⦁	Загальний огляд предметної області


Сучасний ринок стартапів швидко розвивається, пропонуючи нові ідеї та інноваційні продукти, проте для досягнення успіху та стійкого розвитку їм потрібна фінансова підтримка. На жаль, процес залучення інвестицій часто виявляється складним та неструктурованим. Відсутність прозорих механізмів взаємодії між стартапами та потенційними інвесторами створює серйозні бар'єри для обох сторін.
Однією з ключових проблем, з якими стикаються стартапи, є недостатня поінформованість інвесторів про існування перспективних проектів, що значно обмежує можливості для залучення капіталу. Більшість молодих компаній не мають достатніх ресурсів для проведення маркетингових кампаній або участі у великих інвестиційних заходах, що ще більше ускладнює процес пошуку фінансування.
Крім того, інвестори також стикаються з викликами у вигляді необхідності оцінки численних інвестиційних пропозицій і відсутності ефективних інструментів для відбору найбільш перспективних проектів. Це може призводити до втрати потенційних можливостей або інвестування у невдалі проекти.
Для вирішення цих проблем необхідно створити програмну систему, яка забезпечить автоматизацію процесу розподілення інвестицій у стартапи, спрощуючи пошук та оцінку інвестиційних можливостей. Вона надасть стартапам зручний інструмент для залучення капіталу, а інвесторам – можливість ефективного аналізу і вибору проектів, які відповідають їхнім фінансовим цілям та стратегіям. Ця система сприятиме покращенню доступу до фінансування для інноваційних бізнес-ідей та підтримці економічного зростання, створюючи взаємовигідне середовище для обох сторін.

⦁	Аналіз існуючих аналогів та можливості бізнесу


На сьогоднішній день ринок пошуку інвестицій у бізнес-проекти стикається з суттєвими труднощами у процесі залучення інвестицій, що є важливою частиною їхнього розвитку та успіху. Основна проблема полягає у відсутності ефективних інструментів для з'єднання стартапів з потенційними інвесторами, а також у недосконалих механізмах оцінки і вибору інвестиційних можливостей. Існуючі платформи часто не відповідають всім потребам користувачів, що обмежує їхню ефективність у залученні капіталу.
Аналіз ринку показує, що на сьогоднішній день існує кілька ключових платформ, які намагаються вирішити ці проблеми. Наприклад, платформи такі як AngelList та Crunchbase вже надають можливості для з'єднання стартапів з інвесторами, проте мають певні обмеження. AngelList надає значну кількість даних про стартапи та інвесторів, але її функціональність обмежена в аспекті фільтрації та видимості менш відомих проектів. Crunchbase забезпечує інформацію про стартапи та їх фінансові результати, але не має достатньої гнучкості у пошуку та аналізі інвестиційних можливостей.
Відсутність специфічних інструментів для детальної оцінки стартапів і можливостей для адаптивного підбору проектів є значними недоліками в цих платформах. Наша програмна система вирішує ці проблеми, надаючи вдосконалені алгоритми для автоматизованого підбору стартапів відповідно до інвестиційних уподобань і критеріїв. Система буде забезпечувати інтерактивні функції для глибшого аналізу проектів, що дозволить інвесторам більш ефективно оцінювати ризики та потенціал стартапів.
Монетизація нашої системи передбачає впровадження підписки на розширені аналітичні інструменти, які нададуть інвесторам і стартапам доступ до детальних даних та прогнозів. Окрім того, платформа буде пропонувати опції для просування стартапів і підвищення їх видимості за додаткову плату. Таким чином, наша система створює унікальну цінність на ринку, заповнюючи існуючі прогалини та відповідаючи на сучасні вимоги та тренди в інвестиційній сфері.


⦁	Аналіз потреб користувачів


Основними категоріями користувачів системи є підприємці та інвестори. Щоб розробити програмну систему, яка задовольняє потреби обох сторін, важливо розглянути їхні основні вимоги та очікування, зокрема ті, що наразі не покриваються існуючими рішеннями. Нижче наведено ключові потреби кожної групи користувачів.
Потреби підприємців:
1. Потреба в зручному інтерфейсі для створення та управління запитами на інвестиції.
2. Можливість подачі детальних і переконливих бізнес-пропозицій з автоматичним формуванням презентацій.
3. Доступ до інформації про потенційних інвесторів та їхню історію інвестицій.
4. Інструменти для відстеження статусу запитів та отримання зворотного зв'язку від інвесторів.
5. Можливість швидкого оновлення і коригування запитів на основі отриманих коментарів або змін у бізнес-плані.
Потреби інвесторів:
1. Інтуїтивно зрозумілий інтерфейс для пошуку та фільтрації інвестиційних можливостей.
2. Можливість оцінки стартапів за різними критеріями, включаючи фінансові показники та ринковий потенціал.
3. Доступ до інструментів для аналізу ризиків та можливостей, що дозволяють створювати детальні звіти.
4. Функціонал для легкого підписання контрактів і угод з стартапами через платформу.
5. Можливість взаємодії з іншими інвесторами та отримання рекомендацій на основі алгоритмів підбору.


⦁	ПОСТАНОВКА ЗАВДАННЯ
⦁	Бачення програмної системи


Програмна система для автоматизації процесу розподілу інвестицій у бізнес-проекти буде створена з метою вдосконалення взаємодії між стартапами та інвесторами, забезпечуючи ефективний і зручний механізм для обох сторін.
Користувачі системи зможуть швидко і зручно створювати запити на інвестиції, детально описувати свої бізнес-проекти і подавати їх на розгляд потенційним інвесторам. Система автоматично оцінюватиме та рекомендуватиме стартапи на основі заданих критеріїв інвесторів, забезпечуючи більш точний і швидкий підбір можливих інвестицій.
Інвестори, в свою чергу, отримають доступ до розгорнутої бази даних стартапів, з можливістю фільтрації та оцінки проектів за допомогою аналітичних інструментів. Інтерфейс дозволить їм переглядати детальну інформацію про стартапи, здійснювати оцінку їхньої фінансової стабільності і ринкового потенціалу, а також легко підписувати контракти через платформу.
Система також надасть можливість інтерактивного взаємодії між інвесторами та стартапами, включаючи обмін повідомленнями, надання зворотного зв'язку та ведення переговорів, що допоможе оптимізувати процеси залучення інвестицій.
В результаті, стартапи зможуть ефективно знаходити інвесторів, що відповідають їхнім критеріям, а інвестори зможуть знаходити перспективні проекти без зайвих зусиль і витрат часу. Це створить новий стандарт у процесі інвестування, забезпечуючи більшу прозорість і точність у виборі інвестиційних можливостей.



⦁	Основний функціонал системи


Виходячи з основних потреб потенційних користувачів, система повинна включати низку ключових функцій, які забезпечать ефективну взаємодію між інвесторами та стартапами. Наступні основні функції визначаються як критично важливі для досягнення мети проекту та задоволення потреб користувачів:
⦁	реєстрація користувачів у системі (інвестори та стартапи);
⦁	перегляд новин та подій, що стосуються бізнесів і інвестицій;
⦁	додавання та редагування профілю організації або бізнесу;
⦁	створення та публікація запитів на інвестиції бізнесами;
⦁	адаптивний пошук стартапів для інвесторів за критеріями, такими як розмір стартапу та розмір фінансування;
⦁	оцінка та коментування стартапів користувачами, формування рейтингів;
⦁	можливість відстеження новин і оновлень конкретних стартапів;
⦁	підписання контрактів між інвесторами та стартапами;
⦁	генерація аналітичних звітів про фінансування, рейтинг стартапів та інтерес інвесторів;
⦁	оновлення контактної інформації інвесторів та стартапів;
⦁	додавання та зберігання документації до профілів стартапів;
⦁	персоналізовані рекомендації стартапів для інвесторів на основі алгоритмів;
⦁	інтеграція з зовнішніми платіжними системами для здійснення фінансових транзакцій;
⦁	інтерфейс для управління та перегляду статусу підписаних контрактів.

⦁	Обсяг початкового випуску


Основний функціонал, який повинна мати система для пошуку інвесторів та управління стартапами включатиме функції для забезпечення ефективної взаємодії між інвесторами та підприємцями. Веб-платформа забезпечить всі необхідні інструменти для реєстрації користувачів, моніторингу стартапів, а також для управління інвестиціями.
Система підтримуватиме українську та англійську мови. Для забезпечення гнучкості у використанні, система також включатиме можливість інтеграції з різними форматами документів і даних.

Серверна частина включатиме наступний функціонал:
- обробка запитів від користувачів, включаючи реєстрацію, авторизацію і відновлення пароля;
- управління профілями користувачів (інвесторів і підприємців), включаючи редагування інформації;
- зберігання та управління даними про стартапи, включаючи їх профілі, фінансові дані, та інвестиційні пропозиції;
- інтеграція з платіжними системами для обробки транзакцій, підписок і комісій;
- проведення перевірки і валідації даних, зокрема фінансових звітів стартапів;
- генерація та відправка аналітичних звітів користувачам на основі їх запитів;
- реалізація алгоритмів рекомендацій для підбору стартапів інвесторам;
- захист даних, включаючи шифрування паролів, фінансової інформації та конфіденційних даних;
- модерація контенту і відгуків для забезпечення відповідності стандартам платформи;
- резервне копіювання та відновлення даних у разі втрати чи пошкодження;
- підтримка інтеграції з зовнішніми API для отримання додаткових даних і аналітики;
- моніторинг і управління доступом до системи на основі ролей користувачів;
- обробка заявок на підключення і інтеграцію нових стартапів;
- налаштування і управління налаштуваннями платформи і її компонентів.

Клієнтська частина включатиме наступний функціонал:
- реєстрація і авторизація користувачів, включаючи відновлення пароля;
- створення і редагування профілів інвесторів і підприємців;
- пошук і фільтрація стартапів за різними критеріями (рейтинг, тип інвестицій, фінансові показники);
- перегляд і додавання інформації про стартапи, включаючи фінансові дані і бізнес-плани;
- оцінювання стартапів і залишення відгуків;
- підписання і управління контрактами між інвесторами і підприємцями;
- отримання персоналізованих рекомендацій стартапів на основі профілю і інвестиційних уподобань;
- перегляд новин, оновлень і аналітичних звітів про стартапи;
- взаємодія через вбудовану систему чату або повідомлень для обговорення умов інвестицій;
- моніторинг і аналіз власних інвестицій і взаємодій з платформою;
- налаштування сповіщень про нові стартапи, оновлення і важливі події;
- підтримка багатомовності (українська та англійська мови) з можливістю перемикання між мовами.


⦁	Обсяг наступних випусків 


Для подальшого розвитку платформи передбачено розширення функціональності. Наступні випуски будуть зосереджені на інтеграції розумних пристроїв для покращення процесів моніторингу та аналізу даних, а також на створенні мобільного застосунку, що забезпечить ще більш зручне і використання системи користувачами.

В майбутньому система включатиме повноцінний мобільний клієнт, що матиме наступний функціонал:
- підтримка повноцінного доступу до всіх функцій платформи через мобільний застосунок, включаючи реєстрацію, авторизацію, пошук стартапів, та управління інвестиціями;
- реалізація push-сповіщень про нові можливості інвестування, оновлення стартапів та важливі події;
- можливість сканування документів за допомогою камери смартфона для швидкого завантаження необхідних матеріалів на платформу;
- підтримка голосових команд і пошуку для швидшого доступу до функцій платформи;
- інтеграція з календарями користувачів для автоматичного створення подій на основі запланованих зустрічей або важливих дедлайнів;

Також планується інтеграція розумних пристроїв до системи. Вони матимуть наступні функції:
- підключення до розумних сенсорів та пристроїв для моніторингу діяльності підприємців, таких як фінансові датчики або сенсори обліку виробничих процесів;
- впровадження системи автоматизованого збору даних від розумних пристроїв для аналізу показників стартапів у режимі реального часу;
- інтеграція з розумними аналітичними інструментами для надання інвесторам більш детальної інформації про стан і прогрес стартапів;
- можливість дистанційного управління розумними пристроями для оптимізації бізнес-процесів, наприклад, автоматизація звітності та контролю ресурсів;
- підтримка нових протоколів безпеки для захисту даних, що передаються між розумними пристроями і платформою.


⦁	Обмеження та винятки 


При створенні платформи прийнято рішення про деякі обмеження, які вплинуть на функціональність продукту. Зокрема, система не підтримуватиме можливість інтеграції з іншими інвестиційними платформами або фінансовими інструментами, що може обмежити зручність використання для користувачів, які звикли до інших платформ. Мобільний застосунок на перших етапах буде доступний лише для операційної системи Android, тому користувачі iOS не зможуть скористатися всіма перевагами платформи. Крім того, система не передбачає можливості автоматичного перевірки юридичної інформації про стартапи, тож інвестори мають самостійно здійснювати всі необхідні перевірки перед укладанням угод.
На початковому етапі платформа не включатиме функціонал для підтримки багатомовності, окрім української та англійської, що може обмежити доступ для міжнародних користувачів. Також, на відміну від деяких конкурентів, система не матиме можливості автоматичного імпорту фінансових звітів зі сторонніх бухгалтерських програм, що може ускладнити процес ведення фінансового обліку для підприємців. Функціональність платформи буде обмежена в плані аналітики, і вона не надаватиме розширених інструментів для прогнозування фінансових показників або автоматизованого планування бізнесу. Нарешті, платформа не передбачає інтеграції з розумними пристроями інших виробників для автоматизації бізнес-процесів, що може бути важливим для деяких користувачів.

⦁	Робоче середовище

Система призначена для глобального використання, з охопленням користувачів на всіх континентах, що зумовлює необхідність підтримки різних часових поясів та врахування міжнародних вимог. На момент випуску система підтримуватиме українську та англійську мови, з можливістю подальшого додавання інших мов для забезпечення зручності користування.
Дані в системі збиратимуться з різних місць, але централізоване зберігання даних забезпечить їх доступність і цілісність незалежно від географічного розташування користувачів. Важливим критерієм для функціонування системи є забезпечення цілодобового доступу без вихідних, що є критичним для користувачів, які ведуть бізнес у різних часових поясах. Всі планові технічні роботи повинні виконуватись у мінімальні терміни, щоб уникнути тривалих перебоїв у роботі.
Основними вимогами до системи є висока доступність, надійність і продуктивність, що дозволить обробляти великі обсяги даних і запитів у реальному часі. Система повинна гарантувати безпеку та захист даних, дотримуючись сучасних стандартів інформаційної безпеки. 
Веб-застосунок буде створено з використанням технологій Angular 17, HTML, CSS для клієнтської частини; .NET,  ASP.NET Core, Entity Framework Core — для серверної частини. Для збереження даних буде використовуватися база даних Microsoft SQL Server. Клієнтський додаток для Android розроблятиметься на платформі .MAUI. Програмне забезпечення для інтеграції з розумними пристроями буде створене на платформі Arduino з використанням мови програмування C++ за допомогою інструментів Arudino IDE.
⦁	АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ
⦁	Загальна архітектури системи


Архітектура системи розроблена з урахуванням вимог до масштабованості, надійності та безпеки. Вона включає декілька основних компонентів, таких як серверна частина, база даних, веб-клієнт, мобільний застосунок і розумні пристрої, які взаємодіють між собою через стандартизовані протоколи та інтерфейси. Архітектура побудована на основі клієнт-серверної моделі взаємодії. Основна мета цієї архітектури — забезпечити ефективну і безпечну обробку даних, зручний доступ до функціоналу системи для користувачів на різних платформах, а також можливість інтеграції з зовнішніми пристроями для збору і обробки додаткових даних.
Серверна частина є основним ядром системи, що відповідає за обробку запитів від клієнтів, управління даними та інтеграцію з іншими компонентами. Вона взаємодіє з базою даних SQL Server через ORM Entity Framework Core, що забезпечує зручний доступ до даних і їх маніпуляцію без необхідності написання SQL-запитів вручну.
Взаємодія між серверною частиною та клієнтами (веб-клієнтами, мобільними додатками) відбувається через протокол HTTP/HTTPS, що гарантує безпеку передачі даних. Клієнт надсилає HTTP-запити до кінцевих точок API, що обробляються відповідними контролерами на сервері. Контролери відповідають за маршрутизацію запитів до відповідних сервісів або модулів, які виконують бізнес-логіку та здійснюють операції з даними.
Для зберігання даних використовується реляційна база даних SQL Server, яка забезпечує високу продуктивність, масштабованість і надійність зберігання інформації. Entity Framework Core використовується для створення та управління моделлю даних, що дозволяє абстрагуватися від специфічних SQL-запитів та забезпечує більш гнучку і швидку розробку.
База даних зберігає всю необхідну інформацію, включаючи дані користувачів, дані про стартапи, інвестиції, а також логування всіх транзакцій та дій користувачів у системі.
Веб-клієнт розроблений з використанням Angular 17, HTML, CSS, JavaScript і TypeScript. Він є основним інтерфейсом користувача для взаємодії з системою через веб-браузер. Веб-клієнт здійснює HTTP-запити до серверної частини через кінцеві точки API для отримання та відправлення даних. Отримані дані потім обробляються і відображаються в інтуїтивному інтерфейсі користувача.
Комунікація між веб-клієнтом і серверною частиною відбувається по протоколу HTTPS для забезпечення безпеки передачі даних, що є критично важливим, особливо при обробці конфіденційної інформації користувачів і фінансових даних.
Мобільний застосунок розроблений з використанням Xamarin з мовою програмування C# .NET, що дозволяє створити кросплатформний додаток для Android. Мобільний додаток має схожий функціонал з веб-клієнтом, але оптимізований для мобільних пристроїв.
Взаємодія з сервером здійснюється аналогічно веб-клієнту, через HTTP/HTTPS-запити до кінцевих точок API. Мобільний додаток може працювати в режимі офлайн, зберігаючи дані локально на пристрої та синхронізуючи їх із сервером при відновленні інтернет-з’єднання.
Розумні пристрої інтегруються в систему через мобільний додаток. Вони передають дані на мобільний пристрій по Bluetooth, після чого мобільний застосунок відправляє ці дані на сервер для подальшої обробки. Розумні пристрої можуть включати різні сенсори та контролери, які збирають дані про навколишнє середовище або стан об'єктів (наприклад, сенсори температури, вологості, руху тощо).
Взаємодія між компонентами відображена на діаграмі розгортання 
(рис. 3.1). 

 
Рисунок 3.1 – Діаграма розгортання системи


⦁	Проектування бази даних


Для проекту було обрано реляційну модель даних, яка містить основні сутності та їхні зв'язки, що відповідають бізнес-логіці системи. Розробка бази даних розпочалася з моделювання ER-діаграми, яка відображає структуру даних та відносини між ними. В процесі проєктування було прийнято рішення використовувати підхід «code first», що дозволяє генерувати базу даних безпосередньо з кодових моделей у середовищі розробки, полегшуючи зміни в структурі даних і підтримку коду.
ER-модель була побудована з урахуванням основних бізнес-вимог і включає такі сутності: користувачі, стартапи, інвестори, події, відгуки, новини, організації, контакти. Зв'язки між цими сутностями відображають логічні взаємодії між різними компонентами системи. Наприклад, користувачі можуть бути пов'язані з однією або кількома організаціями, інвестори можуть брати участь у різних стартапах, а стартапи можуть мати кілька відгуків та новин.
У процесі проєктування бази даних всі таблиці були нормалізовані до третьої нормальної форми. Це допомогло уникнути надлишкових даних і забезпечити цілісність та несуперечність даних у системі. Кожна таблиця бази даних має первинні та зовнішні ключі для підтримки посилальної цілісності між сутностями.

Основні сутності бази даних:
- користувачі: зберігають інформацію про всіх зареєстрованих користувачів системи, включаючи їхні ролі (інвестор, представник стартапу), контактні дані та статус.
- стартапи: містять дані про стартапи, включаючи назву, опис, дату створення, статус фінансування та інформацію про команду.
- інвестори: містять інформацію про інвесторів, їхній профіль, історію інвестицій, а також відгуки про них.
- події: таблиця для зберігання інформації про події, що організовуються клубом інвесторів, включаючи дату, місце проведення та список учасників.
- відгуки: зберігають відгуки користувачів про стартапи або інвесторів, допомагаючи оцінити репутацію та надійність учасників ринку.
- новини: включають інформаційні статті та новини, пов'язані з діяльністю клубу, стартапами та ринком інвестицій.
- організації: містять дані про компанії та організації, які є учасниками клубу, з детальною інформацією про їхню діяльність і співробітників.
ER-діаграма відображена на рисунку 3.2

 
Рисунок 3.2 – ER-діаграма, що відображає модель даних




⦁	Архітектура серверної частини


Серверна частина додатку клубу інвесторів розроблена з використанням платформи .NET 6.0 і мови програмування C#. Для побудови Web API застосовується технологія ASP.NET Core, яка забезпечує гнучкість, високу продуктивність і безпеку. Архітектура серверної частини має кілька шарів, що дозволяє відокремити бізнес-логіку від доступу до даних та інтерфейсів користувача. Цей підхід сприяє кращій структурованості коду, підвищенню масштабованості та легкості підтримки системи.
Для доступу до даних використовується ORM Entity Framework Core, яка дозволяє працювати з базою даних SQL Server, забезпечуючи ефективне зберігання та маніпуляцію даними. Система дотримується архітектурного стилю RESTful, що дозволяє легко інтегрувати серверну частину з різними клієнтськими додатками та забезпечує стандартизацію взаємодії через HTTP-запити.
Серверна частина включає кілька основних компонентів: контролери, сервіси та моделі. Контролери відповідають за обробку HTTP-запитів, взаємодіючи з сервісами, які реалізують бізнес-логіку додатку. Сервіси, в свою чергу, звертаються до контексту бази даних для отримання даних з БД. Сутності бази даних представлені у вигляді моделей.
Для забезпечення гнучкості та масштабованості система використовує паттерн впровадження залежностей (Dependency Injection). Це дозволяє динамічно замінювати компоненти без необхідності зміни коду інших частин програми, що робить систему легшою в підтримці та розширенні.
Для підвищення безпеки система реалізує механізми аутентифікації та авторизації за допомогою JWT (JSON Web Token). Це дозволяє забезпечити безпечний доступ до ресурсу додатку і зберігає дані користувачів у захищеному вигляді. Паролі користувачів зберігаються у хешованому вигляді, що унеможливлює їхнє розшифрування у випадку несанкціонованого доступу до бази даних.
Програмний код серверної частини поділений на пакети. Додатково використовується декілька зовнішніх бібліотек. Пакетну структуру програмної системи наведено на діаграмі пакетів (див. рис. 3.3).

 
Рисунок 3.3 – Діаграма пакетів для серверної частини


⦁	Архітектура клієнтської браузерної частини


Для розробки клієнтської частини було обрано фреймворк Angular, що дозволяє створювати односторінкові застосунки (SPA) з високою продуктивністю та гнучкістю. Angular побудований на мові програмування TypeScript, що забезпечує статичну типізацію і полегшує відладку та підтримку коду. Застосунок було створено за допомогою Angular CLI, що автоматизує налаштування проєкту та управління залежностями. Для стилізації компонентів використовуються каскадні таблиці стилів SCSS, які додають гнучкості у розробці інтерфейсу користувача.
Основу клієнтської частини складають компоненти, які відповідають за відображення різних частин користувацького інтерфейсу, таких як сторінки реєстрації, авторизації, перегляду стартапів та відгуків. Кожен компонент включає в себе HTML-шаблон для структури сторінки, CSS або SCSS для стилізації, файл TypeScript для логіки роботи компоненту і файл для тестування.
Клієнтська частина побудована за модульною архітектурою. Основний модуль програми - AppModule, який включає в себе всі основні компоненти, сервіси, директиви та маршрути. Модуль маршрутизації (RoutingModule) відповідає за управління навігацією між різними компонентами додатку. Коли користувач взаємодіє з системою, модуль маршрутизації визначає, який з компонентів потрібно завантажити і відобразити, не перезавантажуючи сторінку, що дозволяє додатку залишатися швидким і інтерактивним. Бізнес-логіка розподілена між модулями, відповідно до функціоналу, який у ній знаходиться. Також підключено декілька зовнішніх бібліотек, таких як primeng, ngx-translate. Детальну модульну структуру проекту наведено на діаграмі пакетів (рис. 3.4).

 
Рисунок 3.4 – Діаграма пакетів браузерної клієнтської частини

Проект складається з декількох компонентів, які логічно згруповано. Ця структура відображена на діаграмі компонентів (рис. 3.5)
 
 
Рисунок 3.5 – Діаграма компонентів клієнтської частини

Клієнтська частина взаємодіє з серверною частиною через HTTP-запити, використовуючи сервіс HttpClient, який є частиною Angular і дозволяє надсилати асинхронні запити до API. Це забезпечує ефективну обробку даних та інтеграцію з сервером. Використання бібліотеки RxJS дозволяє легко керувати асинхронними подіями та потоками даних, забезпечуючи високу продуктивність та масштабованість додатку.
Для забезпечення безпеки обміну даними з сервером використовується протокол HTTPS, який захищає дані від несанкціонованого доступу. Весь процес аутентифікації користувачів реалізовано за допомогою JWT (JSON Web Token), що забезпечує безпечний доступ до ресурсу додатку.
Основні візуальні компоненти було створено на базі стандартних компонентів Angular, а для покращення користувацького досвіду використовувалися компоненти з бібліотеки PrimeNG. Ці компоненти забезпечують сучасний дизайн та широкий функціонал, що підвищує зручність використання додатку.


⦁	РЕЗУЛЬТАТ КОДУВАННЯ ПРОГРАМНОЇ СИСТЕМИ 
⦁	Опис серверної частини


Серверна частина реалізована з використанням технологій .NET 6.0, ASP.NET Core. Для розробки використовувалися різноманітні допоміжні пакети і фреймворки, зокрема ASP.NET Core Identity для управління аутентифікацією та авторизацією, Automapper для спрощення перетворення об'єктів між різними шарами додатку, BCrypt.net для безпечного хешування паролів, а також AspNetCore JwtBearer для роботи з JWT токенами.
Усі дані в системі зберігаються у базі даних SQL Server, при цьому забезпечено підтримку кодування UTF-8 та ASCII, що дозволяє зберігати та обробляти інформацію різними мовами. Інтернаціоналізація реалізована через підтримку різних часових поясів, при цьому всі дати зберігаються у форматі UTC. Система також дозволяє вибирати різні одиниці вимірювання, що підвищує зручність для користувачів з різних регіонів.
Серверна частина дотримується архітектурного стилю REST, що забезпечує простий та зрозумілий інтерфейс для взаємодії з іншими частинами системи через REST API. Кінцеві точки API логічно згруповані та обробляються відповідними контролерами. Клієнтські запити обробляються на сервері, а отримані дані повертаються у форматі JSON, що дозволяє легко інтегрувати серверну частину з різними клієнтськими додатками, включаючи веб- і мобільні застосунки. Специфікація REST наведена у таблиці 1

Таблиця 1 – Специфікація REST
Метод	Кінцева точка	Опис
POST	api/Auth/register	Реєстрація користувача
POST	api/Auth/login	Авторизація користувача
POST	api/Investors/add	Додавання інветора
Продовження таблиці 1
GET	api/Investors/Investor	Отримати список усіх інвесторів
GET	api/News/News	Отримати усі новини
POST	api/News/News	Додати новину
DELETE	api/News/{id}	Видалити новину
GET	api/Business	Отримати усі бізнеси для інвестицій
POST	api/Business/add	Додати бізнес
POST	api/Business/add/Review	Додати відгук до бізнесу
GET	api/Business/Review	Отримати відгуки про бізнес
GET	api/Transactions/InvestmentReq/{id}	Отримати усі інвестеційні пропозиції щодо певної пропозиції
POST	api/Transactions/CreateInvestmentReq	Створити інвестеційну пропозицію
DELETE	api/Transactions/DeleteInvestmentReq	Видалити інвестеційну пропозицію
POST	api/Transactions/InvestmentByEmail	Отримати усі інвестеційні пропозиції користувача по email
GET	api/Transactions/Contract/{id}	Отримати контракт на інветицію за id
POST	api/Transactions/CreateContract	Створити контракт на інвестицію
DELETE	api/Transactions/DeleteContract	Видалити контракт на інвестицію

Продовження таблиці 1
GET	api/Transactions/ContractByEmail	Отримати усі контракти за email
GET	api/Users/users	Отримати усіх користувачів
GET	api/Users/{id}	Отримати користувача за id
DELETE	api/Users/{id}	Видалити користувача за id
POST	api/Users/ban/{id}	Заблокувати користувача за id

Для деталізації можливостей взаємодії користувачів з серверною частиною була створена діаграма прецедентів. На ній відображені усі можливі запити різних категорій користувачів до серверної  частини (рис. 4.1)

 
Рисунок 4.1 – Діаграма прецедентів для відображення можливих дій користувачів серверної частини
Адміністрування базою даних можна здійснювати як програмним шляхом через API кінцеві точки, так і через традиційні інтерфейси для роботи з SQL Server. Для забезпечення безпеки реалізовано хешування паролів та певних кінцевих точок, що захищає дані користувачів та запити від несанкціонованого доступу. Авторизація користувачів відбувається за допомогою JWT (JSON Web Token), що дозволяє безпечно перевіряти особу користувача і підтримувати сесії.
Запуск серверного застосунку можливий на будь-якому пристрої з підключенням до Інтернету і встановленим пакетом .NET. Для налаштування застосунку необхідно вказати рядок підключення до бази даних у конфігураційному файлі та визначити порти для запуску сервера. Публікація серверної частини у хмарний сервіс Azure може здійснюватися як за допомогою Visual Studio, так і вручну. Для цього потрібно створити відповідний простір у хмарі, розгорнути базу даних SQL Server та налаштувати рядок підключення у конфігураційному файлі.
Фрагменти програмного коду серверної частини наведено у додатку А.

⦁	Опис клієнтської частини

Клієнтська частина реалізована на платформі Angular. Для підвищення зручності користувачів, додаток підтримує інтернаціоналізацію та локалізацію. Реалізовано підтримку кількох мов, зокрема англійської та української. Зміна мови доступна на головній сторінці додатку, а переклад текстів на всі доступні сторінки здійснюється за допомогою бібліотеки ngx-translate, яка використовує JSON-файли для зберігання ключів і значень перекладу.
Застосунок також підтримує введення даних різними мовами та дозволяє зберігати ці дані на сервері без проблем. Підтримка різних валют, таких як долари та гривні, також реалізована відповідно до обраної локалізації, що забезпечує зручність у фінансових операціях та відображенні інформації про інвестиції.
Клієнтська частина додатку включає різноманітний функціонал для різних типів користувачів, зокрема інвесторів, менеджерів та адміністраторів. Реалізовані можливості адміністрування включають модерацію користувачів, що дозволяє блокувати або розблоковувати облікові записи, а також додавати та редагувати глобальні події і новини, що стосуються інвестиційної діяльності.
Безпека даних є ключовим аспектом у реалізації клієнтської частини. Авторизація користувачів здійснюється через механізм JSON Web Token (JWT), що забезпечує захист конфіденційних даних. URL-адреси, що містять чутливу інформацію, зберігаються у захищеному вигляді, а паролі передаються через захищений протокол у хешованому форматі, що додатково забезпечує захист особистої інформації користувачів.
При розробці клієнтської частини дотримувались принципів чистого коду, що забезпечує масштабованість і легкість у підтримці та розширенні додатку. Архітектура системи спроектована таким чином, що дозволяє без проблем додавати нові функції та вдосконалювати існуючі. Для найменування файлів і елементів коду використовувалися конвенції Angular і TypeScript, що забезпечує консистентність і легкість у читанні коду.
Клієнтська частина веб-додатку доступна через будь-який сучасний браузер за адресою серверу, на якому розгорнуто застосунок. Взаємодія користувача з системою здійснюється через зручний графічний інтерфейс, що включає усі необхідні функції для ефективного управління інвестиціями та участі в клубі інвесторів. Функціональність додатку детально описана на діаграмі прецедентів клієнтської частини, що відображає всі можливі дії користувачів і їх взаємодію з системою (рис. 4.2.1). Для деталізації послідовності дій підприємців при взаємодії з системою була створена діаграма діяльності (рис. 4.2.2).
Фрагменти програмного коду клієнтської частини наведено у додатку Б.
 
Рисунок 4.2.1 – Діаграма прецедентів для відображення можливих дій користувачів клієнтської частини


 
Рисунок 4.2.2 – Діаграма діяльності для деталізації процесу 
взаємодії з системою



⦁	Опис взаємодії з системою через веб-інтерфейс

Після входу на платформу користувач потрапляє на головну сторінку. Тут він має можливість авторизуватися у систему або зареєструватися (рис. 4.3).

 
Рисунок 4.3 – Відображення головної сторінки

Увесь інтерфейс застосунку перекладено українською та англійською мовами. Для зміни мови інтерфейсу необхідно натиснути на кнопку у головному меню зверху. Після зміни мови інтерфейс автоматично перекладається (рисунок 4.4).
 
Рисунок 4.4 – Переклад інтерфейсу

	Для авторизації або реєстрації необхідно обрати відповідний пункт у головному меню зверху. Після чого користувач потрапляє на відповідну сторінку (рисунок 4.5). На цих сторінках присутня валідація усіх полів (рисунок 4.6).

 
Рисунок 4.5 – Сторінка реєстрації
 
Рисунок 4.6 – Валідація полів форми реєстрації

	Після успішної авторизації в якості підприємця користувач потрапляє на сторінку зі своїми бізнесами (рисунок 4.7). Тепер йому доступний функціонал для взаємодії з інвесторами.

 
Рисунок 4.7 – Інтерфейс сторінки зі списком власних бізнесів

За допомогою випадаючого бокового меню (рисунок 4.10) користувач може переглянути список усіх бізнесів інших підприємців (рисунок 4.8), а також ознайомитись з новинами (рис. 4.9), які однакові і доступні для ознайомлення як підприємцям, так і інвесторам.

 
Рисунок 4.8 – Список усіх бізнесів

 
Рисунок 4.9 – Сторінка з новинами

 
Рисунок 4.10 – Бокове меню у застосунку

	На сторінці зі своїми бізнесами підприємець має можливість створити власний новий бізнес, натиснувши на відповідну кнопку. Йому потрібно ввести такі поля як назва, опис, статус стартапу, тип капіталу, посилання на документацію, необхідний бюджет та терміни (рисунок 4.11).
	Також підприємець має змогу редагувати дані свого бізнесу 
(рисунок 4.12).
 
Рисунок 4.11 – Форма для додавання власного бізнесу

 
Рисунок 4.12 – Форма редагування власного бізнесу
	Інша роль користувачів, яка представлена в системі – це інвестори. Після авторизації у систему в якості інвестора користувач потрапляє у свій кабінет інвестора (рисунок 4.13).

 
Рисунок 4.13 – Кабінет інвестора

Інвестори, як і інші користувачі, мають змогу переглядати список доступних бізнесів для інвестицій. Однак для інвесторів доступний розширений функціонал взаємодії з цим списком. Інвестори можуть ставити оцінки підприємцям для формування їх рейтингу (рисунок 4.14), а також пропонувати контракти на інвестиції, заповнивши форму (рисунок 4.15).

 
Рисунок 4.14 – Оцінювання підприємців інвесторами

 
Рисунок 4.15 – Пропозиція інвестиції у проект

	Інвестори також можуть видаляти свої пропозиції, поки підприємці не розглянули їх (рисунок 4.16).

 
Рисунок 4.16 – Видалення інвестиційної пропозиції

	Підприємці у своєму кабінеті після надходження інвестиційної пропозиції мають змогу розглянути її, а також відхилити або прийняти (рисунок 4.17).
 
Рисунок 4.17 – Розгляд інвестиційної пропозиції підприємцем

	Якщо обидві сторони погоджуються на інвестиційну пропозицію, обговорюють усі деталі угоді і підтверджують пропозицію, то у обох сторін в електронному кабінеті з’являються підписні контракти з умовами згоди (рисунок 4.18).

 
Рисунок 4.19 – Підписані контракти.

	У системі передбачена ще одна категорія користувачів – адміністратори. Вони мають змогу видаляти некоректні бізнес-пропозиції (рисунок 4.20), а також додавати, редагувати та змінювати новини (рисунки 4.21, 4.22).
 
Рисунок 4.20 – Сторінка адміністратора зі списком новин

 
Рисунок 4.21 – Сторінка адміністратора для видалення новин

 
Рисунок 4.22 – Сторінка адміністратора для додавання новин


ВИСНОВКИ

В рамках виконання курсового проєкту було набуто практичний досвід у проєктуванні та створенні програмних систем, що включають різноманітні компоненти, взаємопов'язані між собою. Проєктування та реалізація системи для автоматизації розподілення інвестицій включала розробку складних архітектурних рішень для серверної частини, клієнтської частини, а також інтеграцію з базою даних, що дало змогу створити функціональну та масштабовану платформу.
Під час реалізації проекту було проведено детальний аналіз предметної області, включаючи вивчення потреб основних категорій користувачів: інвесторів, підприємців та адміністраторів. На основі цього аналізу були визначені ключові функції та можливості, які повинні бути реалізовані в системі. Розроблено серверну частину, що використовує технології ASP.NET Core та Entity Framework Core для забезпечення взаємодії з базою даних, а також клієнтську частину, створену за допомогою Angular для забезпечення інтуїтивно зрозумілого інтерфейсу користувача.
Всі частини системи були спроєктовані з дотриманням принципів чистої архітектури, включаючи архітектурні стилі та патерни, що дозволяє забезпечити масштабованість та підтримуваність системи. Впроваджено принципи DRY (Don't Repeat Yourself), KISS (Keep It Simple, Stupid) та SOLID, що забезпечують високу якість коду та гнучкість системи.
Особлива увага була приділена безпеці даних, зокрема через використання JWT для авторизації та захисту конфіденційної інформації. Локалізація та інтернаціоналізація системи забезпечують підтримку кількох мов і валют, що підвищує зручність для користувачів з різних країн.
Проєктування та реалізація даної системи значно покращили навички у створенні складних програмних систем, управлінні базами даних та розробці веб-додатків. Результати роботи включають детальне описання функціоналу системи, демонстрацію архітектурних рішень і реалізацію основних вимог. Для перевірки функціональності системи було проведено тестування основних сценаріїв її використання [5]. Код системи розміщено в публічному репозиторії для подальшого перегляду та використання [6].
Розроблена система відповідає поставленим вимогам і може бути використана для автоматизації процесів у сфері інвестицій.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. Мартін Р. Чиста архітектура. Харків: Фабула, 2019. 368 с.
2. Мартін Р. Чистий код: створення і рефакторинг за допомогою 
AGILE. Харків: Фабула, 2019. 416 с.
2. Kamal R. Embedded Systems - Architecture, Programming and Design. Tata McGraw Hill, 2008.
3. Методичні вказівки до курсової роботи з навчальної дисципліни «Архітектура програмного забезпечення» для студентів усіх форм навчання спеціальності 121 – «Інженерія програмного забезпечення» / Упоряд. В.О. Лещинський, І.О. Лещинська, І.П. Сокорчук. Харків: ХНУРЕ, 2021. 37 с.
4. ASP.NET documentation. Microsoft Learn. URL: https://learn.microsoft.com/en-us/aspnet/core (Дата звернення: 29.08.2024).
5. Функціональне тестування програмної системи для автоматизації розподілення інвестицій для бізнес-проектів. URL: https://youtu.be/JeJzEYiGx5E (Дата звернення 29.08.2024).
6. Репозиторій з програмним кодом програмної системи для автоматизації розподілення інвестицій для бізнес-проекті. URL: https://github.com/StanislavTkachenko0/apzkr-pzpi-21-6-tkachenko-stanislav (Дата звернення 29.08.2024).
     

ДОДАТОК А
Фрагменти коду серверної частини
А.1 Програмний код налаштування серверу

⦁	using InvestorsClub_API.Common.Interfaces;
⦁	using InvestorsClub_API.Common.Services;
⦁	using InvestorsClub_API.DBContext;
⦁	using Microsoft.EntityFrameworkCore;
⦁	
⦁	
⦁	var builder = WebApplication.CreateBuilder(args);
⦁	var configuration = builder.Configuration;
⦁	
⦁	// Add services to the container.
⦁	
⦁	builder.Services.AddControllers();
⦁	// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
⦁	builder.Services.AddEndpointsApiExplorer();
⦁	builder.Services.AddSwaggerGen();
⦁	
⦁	builder.Services.AddDbContext<InvestorsClubContext>(options =>
⦁	    options.UseSqlServer(configuration.GetConnectionString("default")));
⦁	
⦁	builder.Services.AddScoped<IAuthService, AuthService>();
⦁	builder.Services.AddScoped<IUsersService, UsersService>();
⦁	builder.Services.AddScoped<IHashService, HashService>();
⦁	builder.Services.AddScoped<INewsService, NewsService>();
⦁	builder.Services.AddScoped<IStartupsService, StartupsService>();
⦁	builder.Services.AddScoped<IInvestorsService, InvestorsService>();
⦁	builder.Services.AddScoped<IReviewsService, ReviewsService>();
⦁	builder.Services.AddScoped<IRecomendationService, RecomendationService>();
⦁	builder.Services.AddScoped<IInvestmentRequestService, InvestmentRequestService>();
⦁	builder.Services.AddScoped<IContractService, ContractService>();
⦁	
⦁	builder.Services.AddCors(options =>
⦁	{
⦁	    options.AddPolicy("AllowAll", builder =>
⦁	    {
⦁	        builder.AllowAnyOrigin()
⦁	               .AllowAnyMethod()
⦁	               .AllowAnyHeader();
⦁	    });
⦁	});
⦁	builder.Services.AddControllers();
⦁	builder.Services.AddEndpointsApiExplorer();
⦁	builder.Services.AddSwaggerGen();
⦁	var app = builder.Build();
⦁	
⦁	// Configure the HTTP request pipeline.
⦁	if (app.Environment.IsDevelopment())
⦁	{
⦁	    app.UseSwagger();
⦁	    app.UseSwaggerUI();
⦁	}
⦁	app.UseHttpsRedirection();
⦁	app.UseAuthorization();
⦁	app.UseStaticFiles();
⦁	app.UseCors("AllowAll");
⦁	
⦁	app.MapControllers();
⦁	app.Run();

А.2 Програмний код контролеру аутентифікації та авторизації

⦁	using InvestorsClub_API.Common.Interfaces;
⦁	using InvestorsClub_API.Common.Interfaces;
⦁	using InvestorsClub_API.DTO;
⦁	using InvestorsClub_API.Enums;
⦁	using InvestorsClub_API.Models;
⦁	using Microsoft.AspNetCore.Http;
⦁	using Microsoft.AspNetCore.Mvc;
⦁	using Microsoft.IdentityModel.Tokens;
⦁	using System.IdentityModel.Tokens.Jwt;
⦁	using System.Security.Claims;
⦁	using System.Security.Cryptography;
⦁	
⦁	namespace InvestorsClub_API.Controllers
⦁	{
⦁	    [Route("api/[controller]")]
⦁	    [ApiController]
⦁	    public class AuthController : ControllerBase
⦁	    {
⦁	        private readonly IAuthService _authService;
⦁	        private readonly IHashService _hashService;
⦁	        private readonly IInvestorsService _investorsService;
⦁	        private readonly IUsersService _usersService;
⦁	
⦁	        public AuthController(
⦁	            IAuthService authService,
⦁	            IHashService hashService, 
⦁	            IInvestorsService investorsService,
⦁	            IUsersService usersService
⦁	            )
⦁	        {
⦁	            this._authService = authService;
⦁	            this._hashService = hashService;
⦁	            this._investorsService = investorsService;
⦁	            this._usersService = usersService;
⦁	        }
⦁	
⦁	        [HttpPost("register")]
⦁	        public async Task<ActionResult<string>> Register(RegisterDTO registerDTO)
⦁	        {
⦁	
⦁	            var user = new Users()
⦁	            {
⦁	                Email = registerDTO.Email,
⦁	                Password = _hashService.HashPassword(registerDTO.Password),
⦁	                FirstName = null,
⦁	                LastName = null,
⦁	                PhoneNumber = null,
⦁	                Role = registerDTO.Role
⦁	            };
⦁	
⦁	
⦁	            var registrationResult = await _authService.Register(user);
⦁	            
⦁	            if (registerDTO.Role == Roles.Investor)
⦁	            {
⦁	                var newUser = await _usersService.GetUserByEmail(user.Email);
⦁	                var res = await _investorsService.AddInvestorAsync(new Investors()
⦁	                {
⦁	                    UserID = newUser.ID,
⦁	                    InterestsAndPreferences = "",
⦁	                    InvestorType = registerDTO.InvestorType,
⦁	                    Budget = registerDTO.Budget
⦁	                });
⦁	            }
⦁	
⦁	            if (registrationResult == RegistrationResult.LoginExists)
⦁	                return BadRequest("User with this login already exists");
⦁	
⦁	            if (registrationResult == RegistrationResult.EmailExists)
⦁	                return BadRequest("User with this email already exists");
⦁	
⦁	            if (registrationResult == RegistrationResult.OtherError)
⦁	                return BadRequest("Error during registration");
⦁	
⦁	            return Ok(true);
⦁	        }
⦁	
⦁	        [HttpPost("login")]
⦁	        public async Task<ActionResult<string>> Login(AuthDTO authModel)
⦁	        {
⦁	            var user = await _authService.Login(authModel);
⦁	
⦁	            if (user == null)
⦁	            {
⦁	                return Unauthorized();
⦁	            }
⦁	
⦁	            if (user.Banned)
⦁	            {
⦁	                return new ObjectResult("Access forbidden")
⦁	                {
⦁	                    StatusCode = 403
⦁	                };
⦁	            }
⦁	
⦁	            var token = GenerateJwtToken(user);
⦁	
⦁	            return Ok(new
⦁	            {
⦁	                token,
⦁	                user
⦁	            });
⦁	
⦁	        }
⦁	
⦁	        private string GenerateJwtToken(Users user)
⦁	        {
⦁	            var tokenHandler = new JwtSecurityTokenHandler();
⦁	            var key = new byte[16];
⦁	            using (var rng = RandomNumberGenerator.Create())
⦁	            {
⦁	                rng.GetBytes(key);
⦁	            }
⦁	            var tokenDescriptor = new SecurityTokenDescriptor
⦁	            {
⦁	                Subject = new ClaimsIdentity(new[]
⦁	                {
⦁	                    new Claim(ClaimTypes.Email, user.Email!),
⦁	                    new Claim("userId", $"{user.ID}")
⦁	                }),
⦁	                Expires = DateTime.UtcNow.AddDays(7),
⦁	                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256Signature)
⦁	            };
⦁	            var token = tokenHandler.CreateToken(tokenDescriptor);
⦁	            return tokenHandler.WriteToken(token);
⦁	        }
⦁	    }
⦁	}

А.3 Програмний код сервісу рекомендацій з алгоритмом адаптивного підбору проектів для інвестицій

⦁	using InvestorsClub_API.Common.Interfaces;
⦁	using InvestorsClub_API.Common.Interfaces;
⦁	using InvestorsClub_API.DTO;
⦁	using InvestorsClub_API.Enums;
⦁	
⦁	namespace InvestorsClub_API.Common.Services
⦁	{
⦁	    public class RecomendationService : IRecomendationService
⦁	    {
⦁	        private readonly IInvestorsService _investorsService;
⦁	        private readonly IReviewsService _reviewsService;
⦁	
⦁	        public RecomendationService(
⦁	            IInvestorsService investorsService,
⦁	            IReviewsService reviewsService
⦁	            ) 
⦁	        {
⦁	            _investorsService = investorsService;
⦁	            _reviewsService = reviewsService;
⦁	        }
⦁	
⦁	        /// <summary>
⦁	        ///    Returns sorted startups from the most suitable to the investor to the most unsuitable ones.
⦁	        /// </summary>
⦁	        public async Task<IEnumerable<StartupDTO>> SortStartupsByRecommendations(IEnumerable<StartupDTO> startups, string email)
⦁	        {
⦁	            var investor = await _investorsService.GetInvestorByEmailAsync(email);
⦁	
⦁	            if (investor != null)
⦁	            {
⦁	                List<StartupsWithScore> startupsWithScores = new List<StartupsWithScore>();
⦁	
⦁	                foreach (var s in startups)
⦁	                {
⦁	                    var startupWithScore = new StartupsWithScore()
⦁	                    {
⦁	                        Score = await CalculateRelevanceScore(s, investor),
⦁	                        Startup = s
⦁	                    };
⦁	
⦁	                    startupsWithScores.Add(startupWithScore);
⦁	                }
⦁	
⦁	                startups = startupsWithScores.OrderByDescending(item => item.Score).Select(item => item.Startup);
⦁	            }
⦁	
⦁	            return startups;
⦁	        }
⦁	
⦁	        /// <summary>
⦁	        ///     Counts scores that specify a set of matching criteria.
⦁	        ///     Returns scores after algorithmic similarity checks.
⦁	        /// </summary>
⦁	        private async Task<double> CalculateRelevanceScore(StartupDTO startup, InvestorDTO investor)
⦁	        {
⦁	            var reviews = await _reviewsService.GetReviewsByStartupId(startup.ID);
⦁	            double relevanceScore = 0;
⦁	            int sumOfRating = 0;
⦁	
⦁	            // Budget comparison
⦁	            if (startup.RequiredBudget.HasValue && investor.Budget >= startup.RequiredBudget)
⦁	            {
⦁	                double budgetDifference = (double)(investor.Budget - startup.RequiredBudget.Value);
⦁	
⦁	                double maxBudgetDifference = 0.5 * (double)investor.Budget;
⦁	
⦁	                double budgetWeight = budgetDifference / maxBudgetDifference;
⦁	
⦁	                relevanceScore += budgetWeight;
⦁	            }
⦁	
⦁	            // Comparison by investor type
⦁	            if (investor.InvestorType == startup.DesiredInvestorType)
⦁	            {
⦁	                relevanceScore += 2;
⦁	            }
⦁	
⦁	            // Comparison by stage of development
⦁	            switch (startup.DevelopmentStage)
⦁	            {
⦁	                case DevelopmentStage.IdeaStage:
⦁	                    relevanceScore += 1;
⦁	                    break;
⦁	                case DevelopmentStage.LaunchStage:
⦁	                    relevanceScore += 2;
⦁	                    break;
⦁	                case DevelopmentStage.EarlyStage:
⦁	                    relevanceScore += 3;
⦁	                    break;
⦁	                case DevelopmentStage.GrowthStage:
⦁	                    relevanceScore += 4;
⦁	                    break;
⦁	                case DevelopmentStage.MatureStage:
⦁	                    relevanceScore += 5;
⦁	                    break;
⦁	            }
⦁	
⦁	            //startup ranking comparison
⦁	            foreach ( var review in reviews )
⦁	            {
⦁	                sumOfRating += review.Rating;
⦁	            }
⦁	
⦁	            relevanceScore += sumOfRating > 0 ? sumOfRating / reviews.Count() : 0;
⦁	
⦁	
⦁	            // Comparison by investment term
⦁	            if (startup.Deadline.HasValue)
⦁	            {
⦁	                //  The shorter the investment period, the more points
⦁	                relevanceScore += 1 / startup.Deadline.Value;
⦁	            }
⦁	
⦁	            await Console.Out.WriteLineAsync($"{relevanceScore}");
⦁	
⦁	            return relevanceScore;
⦁	        }
⦁	    }
⦁	}

А.4 Програмний код сервісу запитів на інвестиції

⦁	using InvestorsClub_API.Common.Interfaces;
⦁	using InvestorsClub_API.DBContext;
⦁	using InvestorsClub_API.DTO;
⦁	using InvestorsClub_API.Enums;
⦁	using InvestorsClub_API.Models;
⦁	using Microsoft.EntityFrameworkCore;
⦁	
⦁	namespace InvestorsClub_API.Common.Services
⦁	{
⦁	    public class InvestmentRequestService : IInvestmentRequestService
⦁	    {
⦁	        private readonly IStartupsService _startupService;
⦁	        private readonly IInvestorsService _investorsService;
⦁	        private readonly IUsersService _usersService;
⦁	
⦁	        public InvestmentRequestService(
⦁	            IStartupsService startupsService,
⦁	            IInvestorsService investorsService,
⦁	            IUsersService usersService
⦁	            ) { 
⦁	            _startupService = startupsService;
⦁	            _investorsService = investorsService;
⦁	            _usersService = usersService;  
⦁	        }
⦁	
⦁	        public async Task<bool> CreateInvestmentRequest(InvestmentRequests request)
⦁	        {
⦁	            using (var context = new InvestorsClubContext())
⦁	            {
⦁	                context.InvestmentRequests.Add(request);
⦁	
⦁	                await context.SaveChangesAsync();
⦁	
⦁	                return true;
⦁	            }
⦁	        }
⦁	
⦁	        public async Task<DeletingResult> DeleteInvestmentRequestById(int id)
⦁	        {
⦁	            try
⦁	            {
⦁	                using (var context = new InvestorsClubContext())
⦁	                {
⦁	                    var invReq = await context.InvestmentRequests.FindAsync(id);
⦁	
⦁	                    if(invReq != null) 
⦁	                    {
⦁	                        context.InvestmentRequests.Remove(invReq);
⦁	
⦁	                        await context.SaveChangesAsync();
⦁	
⦁	                        return DeletingResult.Success;
⦁	                    }
⦁	
⦁	                    return DeletingResult.ItemNotFound;
⦁	                } 
⦁	            }
⦁	            catch (Exception ex)
⦁	            {
⦁	                return DeletingResult.Failure;
⦁	            }
⦁	        }
⦁	
⦁	        public async Task<InvestmentRequestDTO> GetInvestmentRequestById(int id)
⦁	        {
⦁	            try
⦁	            {
⦁	                using (var context = new InvestorsClubContext())
⦁	                {
⦁	                    var invReq = await context.InvestmentRequests.FindAsync(id);
⦁	
⦁	                    if (invReq != null)
⦁	                    {
⦁	                        return new InvestmentRequestDTO()
⦁	                        {
⦁	                            ID = invReq.ID,
⦁	                            InvestorInfo = await _investorsService.GetInvestorByIdAsync(invReq.InvestorID),
⦁	                            StartupInfo = await _startupService.GetStartupById(invReq.StartupID),
⦁	                            InvestmentAmount = invReq.InvestmentAmount,
⦁	                            InvestmentTerm = invReq.InvestmentTerm
⦁	                        };
⦁	                    }
⦁	
⦁	                    return null;
⦁	                }
⦁	            }
⦁	            catch (Exception ex)
⦁	            {
⦁	                throw new ArgumentNullException(ex.Message, ex);
⦁	            }
⦁	        }
⦁	
⦁	        public async Task<IEnumerable<InvestmentRequestDTO>> GetInvestmentRequestsByInvestorEmail(string email)
⦁	        {
⦁	            try
⦁	            {
⦁	                using (var context = new InvestorsClubContext())
⦁	                {
⦁	                    var investor = await _investorsService.GetInvestorByEmailAsync(email);
⦁	
⦁	                    if (investor != null)
⦁	                    {
⦁	                        var invReqs = await context.InvestmentRequests.Where(inv => inv.InvestorID == investor.ID).ToListAsync();
⦁	                        List<InvestmentRequestDTO> invReqsDTO = new List<InvestmentRequestDTO>();
⦁	
⦁	                        if (invReqs.Any())
⦁	                        {
⦁	                            foreach (var invereq in invReqs)
⦁	                            {
⦁	                                invReqsDTO.Add(new InvestmentRequestDTO()
⦁	                                {
⦁	                                    ID = invereq.ID,
⦁	                                    InvestorInfo = investor,
⦁	                                    StartupInfo = await _startupService.GetStartupById(invereq.StartupID),
⦁	                                    InvestmentAmount = invereq.InvestmentAmount,
⦁	                                    InvestmentTerm = invereq.InvestmentTerm
⦁	                                });
⦁	                            }
⦁	
⦁	                            return invReqsDTO;
⦁	                        }
⦁	
⦁	                        return invReqsDTO;
⦁	                    }
⦁	                    else
⦁	                    {
⦁	                        var user = await _usersService.GetUserByEmail(email);
⦁	
⦁	                        if (user != null)
⦁	                        {
⦁	                            var startupsOfUser = await _startupService.GetStartups(user.Email);
⦁	                            var startupIds = startupsOfUser.Select(s => s.ID).ToList();
⦁	
⦁	                            var invReqs = await context.InvestmentRequests
⦁	                                                            .Where(inv => startupIds.Contains(inv.StartupID))
⦁	                                                            .ToListAsync();
⦁	
⦁	                            List<InvestmentRequestDTO> invReqsDTO = new List<InvestmentRequestDTO>();
⦁	
⦁	                            if (invReqs.Any())
⦁	                            {
⦁	                                foreach (var invereq in invReqs)
⦁	                                {
⦁	                                    invReqsDTO.Add(new InvestmentRequestDTO()
⦁	                                    {
⦁	                                        ID = invereq.ID,
⦁	                                        InvestorInfo = await _investorsService.GetInvestorByIdAsync(invereq.InvestorID),
⦁	                                        StartupInfo = await _startupService.GetStartupById(invereq.StartupID),
⦁	                                        InvestmentAmount = invereq.InvestmentAmount,
⦁	                                        InvestmentTerm = invereq.InvestmentTerm
⦁	                                    });
⦁	                                }
⦁	
⦁	                                return invReqsDTO;
⦁	                            }
⦁	
⦁	                            return invReqsDTO;
⦁	                        }
⦁	                    }
⦁	
⦁	                    return null;
⦁	                }
⦁	            }
⦁	            catch (Exception ex)
⦁	            {
⦁	                throw new ArgumentNullException(ex.Message, ex);
⦁	            }
⦁	        }
⦁	    }
⦁	}
⦁	

ДОДАТОК Б
Фрагменти коду клієнтської частини
Б.1 Програмний код класу для налаштування перекладу

⦁	import {LangChangeEvent, TranslateLoader, TranslateService} from '@ngx-translate/core';
⦁	import { HttpClient } from '@angular/common/http';
⦁	import { TranslateHttpLoader } from '@ngx-translate/http-loader';
⦁	import {LocalizationService} from "../../services/localization.service";
⦁	
⦁	export function HttpLoaderFactory(http: HttpClient): TranslateLoader {
⦁	  return new TranslateHttpLoader(http, './assets/i18n/', '.json');
⦁	}
⦁	
⦁	export class LocalizedComponent {
⦁	  constructor(public translate: TranslateService, public localizationService: LocalizationService) {
⦁	    const lng = localizationService.getLanguage()
⦁	
⦁	    translate.addLangs(['en', 'ua']);
⦁	    this.translate.use(lng);
⦁	
⦁	    this.localizationService.flagLang = lng === 'ua';
⦁	
⦁	    this.translate.onLangChange.subscribe((event: LangChangeEvent) => {
⦁	      console.log(event.lang)
⦁	    });
⦁	  }
⦁	}


Б.2 Програмний код для перевірки прав адміністратора та обмеження доступу до ресурсів

⦁	import {map} from 'rxjs/operators';
⦁	import {Injectable} from "@angular/core";
⦁	import {ActivatedRoute, ActivatedRouteSnapshot, CanActivate, Router, RouterStateSnapshot} from "@angular/router";
⦁	import {Observable, of, takeUntil} from 'rxjs';
⦁	import {AuthService} from "../services/api/auth.service";
⦁	import {UserService} from "../services/api/user.service";
⦁	import {Roles} from "../shared/enums/Roles";
⦁	
⦁	@Injectable()
⦁	export class AccessAdminGuard implements CanActivate {
⦁	
⦁	  constructor(public router: Router,
⦁	              private authService: AuthService,
⦁	              private userService: UserService,
⦁	              private route: ActivatedRoute,) {
⦁	  }
⦁	
⦁	  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> {
⦁	    return of(true);
⦁	    this.userService.getUser(this.userService.getUserInfoFromToken().userId)
⦁	      .pipe(map((u) => {
⦁	        if(this.authService.isAuthenticated() && u.role === Roles.Admin) {
⦁	          return true;
⦁	        } else {
⦁	          this.router.navigate(['/']).then();
⦁	
⦁	          return false;
⦁	        }
⦁	      }))
⦁	  }
⦁	}


Б.3 Програмний код сервісу для авторизації

⦁	import {Inject, Injectable} from '@angular/core';
⦁	import {HttpClient} from "@angular/common/http";
⦁	import {Observable, tap} from "rxjs";
⦁	import {API_URL} from "../../../app-injections-tokens";
⦁	import {ActivatedRoute, Router} from "@angular/router";
⦁	import {AuthResponseModel} from "../../shared/models/auth-models";
⦁	import {JwtHelperService} from "@auth0/angular-jwt";
⦁	
⦁	export const ACCESS_TOKEN_KEY = 'investors_club_token'
⦁	
⦁	@Injectable()
⦁	export class AuthService {
⦁	
⦁	    constructor(
⦁	        private http: HttpClient,
⦁	        @Inject('API_URL') private apiUrl: string,
⦁	        private jwtHelper: JwtHelperService,
⦁	        private router: Router,
⦁	        private route: ActivatedRoute
⦁	    )
⦁	    {}
⦁	
⦁	    register(authInfo: AuthResponseModel): Observable<any> {
⦁	        return this.http.post(`${this.apiUrl}api/Auth/register`, authInfo)
⦁	    }
⦁	
⦁	    login(authInfo: AuthResponseModel): Observable<any> {
⦁	        return this.http.post(`${this.apiUrl}api/Auth/login`, authInfo)
⦁	            .pipe(tap((res: any) => {
⦁	                localStorage.setItem(ACCESS_TOKEN_KEY, res.token);
⦁	            }))
⦁	    }
⦁	
⦁	    isAuthenticated(): boolean {
⦁	        const token = localStorage.getItem(ACCESS_TOKEN_KEY);
⦁	        return !this.jwtHelper.isTokenExpired(token) && !!token;
⦁	    }
⦁	
⦁	    logout() {
⦁	        localStorage.removeItem(ACCESS_TOKEN_KEY);
⦁	        this.router.navigate(['sign', 'in'], { relativeTo: this.route }).then();
⦁	    }
⦁	}


Б.4 Програмний код розмітки головної сторінки

⦁	<div class="introduction-page" style="width: 100%">
⦁	  <div style="position: relative">
⦁	    <img style="width: 100%; height: 85vh"
⦁	         src="assets/images/banner_investorenclub.jpg" alt="banner">
⦁	  </div>
⦁	
⦁	  <div style="position: absolute; width: 100%; height: 100%; z-index: 10; top: 0">
⦁	    <div class="flex flex-direction-column justify-content-between" style="height: 100%">
⦁	      <div class="title-text" style="padding: 5% 0 0 5%; max-width: 80%">
⦁	        {{ 'INTRODUCTION_TITLE' | translate }}
⦁	      </div>
⦁	
⦁	      <div class="flex align-items-center justify-content-end" style="gap: 40px; padding: 0 50px 30px 0">
⦁	        <button
⦁	          pButton
⦁	          [label]="'REGISTER' | translate"
⦁	          [routerLink]="'/sign/up'"
⦁	          style="max-width: 200px; width: 100%"
⦁	          class="p-button p-button-outlined p-button-plain"
⦁	        ></button>
⦁	
⦁	        <button
⦁	          pButton
⦁	          [label]="'SIGN_IN' | translate"
⦁	          [routerLink]="'/sign'"
⦁	          style="max-width: 200px; width: 100%"
⦁	          class="p-button p-button-outlined p-button-plain"
⦁	        ></button>
⦁	      </div>
⦁	    </div>
⦁	  </div>
⦁	</div>